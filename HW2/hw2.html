<!-- Author: Isaiah Mann -->
<!-- Co-Authors: Sara Mathieson (Assignment Template), Anna Zhou (Co-Designed Polygon Code in Lab2) -->
<!-- Description: Implementation of flood and sweep fill algorithms -->

<!DOCTYPE html>
<html>
<head>
<title>Fill Algorithms</title>
<script>
    var canvas;    // DOM object corresponding to the canvas
    var graphics;  // 2D graphics context for drawing on the canvas

    // note: change both for a different background color
    var backgroundColorRGBA = [0, 0, 0, 255];
    var fillColorRGBA = [0, 0, 0, 0];
    var lineColorRGBA = [0, 0, 0, 0];

    var blueColorRGBA = [0, 0, 255, 255];
    var redColorRGBA = [255, 0, 0, 255];
    var yellowColorRGBA = [255, 255, 0, 255];
    var greenColorRGBA = [0, 255, 0, 255];
    var orangeColorRGBA = [255, 165, 0, 255];

    var pixelsChecked = null;
    var maximumFloodFillTolerance = 5;

    function getFormattedColorFromTuple (colorRGBATuple) {
         return "rgba" + formatTupleToString(colorRGBATuple);
    }

    function formatTupleToString (tuple) {
         var tupleString = "(";
         for (var i = 0; i < tuple.length; i++) {
              tupleString += tuple[i];
              if (i < tuple.length - 1) {
                   tupleString += ", ";
              }
         }
         return tupleString + ")";
    }

    // draws a regular polygon with n sides, centered at (centerX,centerY), with radius r
    // WARNING: fillAsync = false will cause stack overflow unless the shape has a small radius
    function drawRegularPolygon(numberOfSides, centerX, centerY, radius, lineColor, fillColor, fillAsync) {
        if (fillAsync == null) {
             fillAsync = false;
        }
        var formattedLineColor = getFormattedColorFromTuple(lineColor);
        var formmatedFillColor = getFormattedColorFromTuple(fillColor);
        graphics.strokeStyle = formattedLineColor;
        var theta = 2 * Math.PI / numberOfSides;
        graphics.beginPath();
        graphics.moveTo (radius + centerX, centerY);
        for (var i = 0; i < numberOfSides; i++) {
            var angle = theta * i;
            x = radius * Math.cos(angle) + centerX;
            y = radius * Math.sin(angle) + centerY;
            graphics.lineTo(x, y);
            graphics.moveTo(x, y);
        }
        graphics.lineTo (radius + centerX, centerY);
        graphics.stroke();
        setFillColor(fillColor);
        setLineColor(lineColor);
        performPreOptimizationForFloodFill(fillColor, backgroundColorRGBA);
        floodFill(centerX, centerY, fillColor, backgroundColorRGBA, fillAsync);
    }

    // fill a shape, starting at the pixel (x,y)
    // note: make sure to set "fillStyle" to the desired fill color
    // before calling this function
    // color parameters should be in RGBA tuples
    // WARNING: If async is set to false, function can easily cause Stack Overflow
    function floodFill(x, y, newColor, oldColor, fillAsync) {
         if (fillAsync == null) {
              fillAsync = false;
         }
         // Check if the equation is still within the canvas
          if (!inCanvasBounds(x, y) || isPixelCheckedByFloodFill(x, y)) {
               return;
          }
          markPixelCheckedByFloodFill(x, y);
          var currentColor = getPixel(x, y)
          if (checkForTupleMatch(currentColor, lineColorRGBA)) {
               return; // base case (hit an edge)
          }
		else if (checkForTupleMatch(currentColor, newColor)) {
               return; // base case (already filled)
          }
		else if (checkForTupleMatch(currentColor, oldColor)) {
               fillPixel(x, y);
               if (!isPixelCheckedByFloodFill(x, y+1)) {  // North
                    if (fillAsync) {
                         scheduleFloodFill(x, y+1, newColor, oldColor, fillAsync)
                    } else {
                         floodFill(x, y+1, newColor, oldColor, fillAsync)
                    }
               }
               if (!isPixelCheckedByFloodFill(x, y-1)) {
                    if (fillAsync) {
                         scheduleFloodFill(x, y-1, newColor, oldColor, fillAsync)
                    } else {
                         floodFill(x, y-1, newColor, oldColor, fillAsync)
                    }
               }
               if (!isPixelCheckedByFloodFill(x+1, y)) {
                    if (fillAsync) {
                         scheduleFloodFill(x+1, y, newColor, oldColor, fillAsync)
                    } else {
                         floodFill(x+1, y, newColor, oldColor, fillAsync)
                    }
               }
               if (!isPixelCheckedByFloodFill(x-1, y)) {
                    if (fillAsync) {
                         scheduleFloodFill(x-1, y, newColor, oldColor, fillAsync)
                    } else {
                         floodFill(x-1, y, newColor, oldColor, fillAsync)
                    }
               }
          }
    }

    function scheduleFloodFill (x, y, newColor, oldColor, fillAsync, delay) {
         if (delay == null) {
              delay = 0;
         }
         setTimeout(function(){
              floodFill(x, y, newColor, oldColor, fillAsync)
         }, delay);
    }

    function initializeFloodFillOptimization () {
         pixelsChecked = [];
         for (var x = 0; x < canvas.width; x++) {
              pixelsChecked.push([]);
              for (var y = 0; y < canvas.height; y++) {
                   pixelsChecked[x].push(false);
              }
         }
    }

    function markPixelCheckedByFloodFill (x, y) {
         if (pixelsChecked[x] == null) {
              pixelsChecked[x] = [];
         }
         pixelsChecked[x][y] = true;
    }

    function isPixelCheckedByFloodFill (x, y) {
         if (pixelsChecked[x] == null || [x][y] == null) {
              return false;
         } else {
              return pixelsChecked[x][y];
         }
    }

    function sweepFill(x, y, oldColor) {
         // TODO: Implement this approach
    }

    function setFillColor(newColorRGBATuple) {
         fillColorRGB = newColorRGBATuple;
         graphics.fillStyle = getFormattedColorFromTuple(fillColorRGB);
    }

    function checkForTupleMatch (tuple1, tuple2, tolerance) {
         if (tolerance == null) {
              tolerance = maximumFloodFillTolerance;
         }
         if (checkTupleLengthMatch(tuple1, tuple2)) {
              var tuplesMatch = true;
              for (var i = 0; i < tuple1.length; i++) {
                   tuplesMatch &= Math.abs(tuple1[i] - tuple2[i]) < tolerance;
                   if (!tuplesMatch) {
                        return false;
                   }
              }
              return tuplesMatch;
         } else {
              return false;
         }
    }

    function checkTupleLengthMatch (tuple1, tuple2) {
         return tuple1.length === tuple2.length;
    }

    function getMaxTupleDifference (tuple1, tuple2) {
        if (checkTupleLengthMatch(tuple1, tuple2)) {
             var maxDifference = 0;
             for (var i = 0; i < tuple1.length; i++) {
                  var currentDifference;
                  if ((currentDifference = Math.abs(tuple1[i] - tuple2[i])) > maxDifference) {
                       maxDifference = currentDifference;
                  }
             }
             return maxDifference;
        } else {
             // For the purposes of this program, non-matching tuple lengths (RGBA vals are invalid)
             return null;
        }
    }

    function setMaximumFloodFillTolerance (newColorRGBATuple, oldColorRGBATuple) {
         maximumFloodFillTolerance = getMaxTupleDifference(newColorRGBATuple, oldColorRGBATuple) / 2;
    }

    function setBackgroundColor(newColorRGBATuple) {
         backgroundColorRGBA = newColorRGBATuple;
    }

    function performPreOptimizationForFloodFill (newColorRGBATuple, oldColorRGBATuple) {
         initializeFloodFillOptimization();
         setMaximumFloodFillTolerance (newColorRGBATuple, oldColorRGBATuple);
    }

    function drawBackground() {
         graphics.fillStyle = getFormattedColorFromTuple(backgroundColorRGBA);
         graphics.fillRect(0,0,canvas.width,canvas.height);
    }

    function setLineColor(newColorRGBATuple) {
         lineColorRGBA = newColorRGBATuple;
    }

    function inCanvasBounds (x, y) {
         return (x >= 0 && x <= canvas.width) && (y >= 0 && y <= canvas.height);
    }

    function colorPixel (x, y, color) {
         graphics.fillStyle = color;
         fillPixel(x, y);
    }

    function fillPixel (x, y) {
         graphics.fillRect(x, y, 1, 1);
    }

    function getPixel (x, y) {
         return graphics.getImageData(x, y, 1, 1).data;
    }

    function draw() {
        // make sure to color the background first, since it doesn't have a default color
        drawBackground();
        drawRegularPolygon(6, 250, 200, 100, blueColorRGBA, yellowColorRGBA, true);
        drawRegularPolygon(5, 100, 100, 50, redColorRGBA, yellowColorRGBA, true);
        drawRegularPolygon(4, 400, 100, 50, greenColorRGBA, yellowColorRGBA, true);
        drawRegularPolygon(20, 250, 50, 25, orangeColorRGBA, yellowColorRGBA, true);
    }

    function init() {
        canvas = document.getElementById("theCanvas");
        graphics = canvas.getContext("2d");
        draw();  // draw something on the canvas
   }

</script>


</head>
<body onload="init()">
    <canvas id="theCanvas" width="525" height="325"></canvas>
</body>
</html>
